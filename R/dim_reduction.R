#' Perform LogTF-IDF on a sparse, binary matrix
#'
#' TF-IDF is Term Frequency-Inverse Document Frequency.
#'
#' This function also includes log scaling, as suggested by Andrew Hill.
#'
#' @param atac_matrix A binary, dgCMatrix of overlaps between cells (columns) and peaks (rows).
#' @param site_frequency_threshold A minimum threshold for the fraction of cells for which each peak must be positive to be retained. Ignored if idf is supplied.
#' @param idf (optional) A precomputed, named numeric vector of IDF weights to apply to the data. Default is NULL, which uses the atac_matrix to compute IDF.
#'
#' @return a sparse matrix of filtered and scaled count values
#' @export
#'
atac_tf_idf <- function(atac_matrix,
                        site_frequency_threshold = 0.03,
                        idf = NULL) {

  cells_per_feature <- Matrix::rowSums(atac_matrix)

  if(is.null(idf)) {
    threshold <- ncol(atac_matrix) * site_frequency_threshold

    filtered_matrix <- atac_matrix[cells_per_feature >= threshold,]
  } else {
    filtered_matrix <- atac_matrix[names(idf),]
  }

  ## Normalize the data with TF-IDFx
  col_sums <- Matrix::colSums(filtered_matrix)
  n_rep <- diff(filtered_matrix@p)

  filtered_matrix@x <- filtered_matrix@x / rep(col_sums, n_rep)
  filtered_matrix@x <- log1p(filtered_matrix@x * 1e5)

  if(is.null(idf)) {
    idf <- log(1 + ncol(filtered_matrix) / Matrix::rowSums(filtered_matrix))
  }

  tf_idf_counts <- filtered_matrix * idf

  tf_idf_counts@x[is.na(tf_idf_counts@x)] <- 0

  list(tf_idf = tf_idf_counts,
       idf = idf)
}

#' Perform SVD on TF-IDF scaled values
#'
#' @param tf_idf_mat A dgCMatrix of LogTF-IDF scaled values, e.g. as generated by atac_tf_idf()$tf_idf_mat
#' @param seed A numeric value to use as a random seed. Default is 3030.
#'
#' @return A list with two objects: pcs, a VD matrix from singular value decomposition; and feature_loadings, a UD matrix from SVD.
#' @export
atac_svd <- function(tf_idf_mat,
                     seed = 3030) {
  set.seed(seed)
  SVD <- irlba::irlba(tf_idf_mat, 50, 50, maxit=1000)
  d_diag <- matrix(0, nrow=length(SVD$d), ncol=length(SVD$d))
  diag(d_diag) <- SVD$d

  SVD_vd <- Matrix::t(d_diag %*% Matrix::t(SVD$v))
  rownames(SVD_vd) <- colnames(tf_idf_mat)
  colnames(SVD_vd) <- paste0('pc_', 1:ncol(SVD_vd))

  rownames(SVD$u) <- rownames(tf_idf_mat)
  colnames(SVD$u) <- paste0('pc_', 1:ncol(SVD_vd))

  list(pcs = SVD_vd,
       feature_loadings = SVD$u)
}

#' Perform Latent Semantic Indexing of a binary matrix
#'
#' This is a wrapper around two functions: atac_tf_idf() and atac_svd()
#'
#' @param atac_matrix A binary, dgCMatrix of overlaps between cells (columns) and peaks (rows).
#' @param site_frequency_threshold A minimum threshold for the fraction of cells for which each peak must be positive to be retained.
#' @param seed A numeric value to use as a random seed. Default is 3030.
#'
#' @return A list with two objects: pcs, a VD matrix from singular value decomposition; and feature_loadings, a UD matrix from SVD.
#' @export
atac_lsi <- function(atac_matrix,
                     site_frequency_threshold = 0.03,
                     seed = 3030) {

  tf_idf_res <- atac_tf_idf(atac_matrix,
                               site_frequency_threshold)

  atac_svd(tf_idf_res$tf_idf_mat,
           seed = seed)
}

#' Compute Jaccard distances
#'
#' @param m a sparse matrix of KNN
#'
#' @return a sparse matrix of Jaccard distances.
#' @export
sparse_jaccard <-  function(m) {

  # common values:
  A <- Matrix::tcrossprod(m)
  A <- as(A, "dgTMatrix")

  # counts for each row
  b <- Matrix::rowSums(m)

  # Jacard formula: #common / (#i + #j - #common)
  A@x <- A@x / (b[A@i+1] + b[A@j+1] - A@x)

  return(A)
}


#' Project a query TF-IDF dataset onto a target SVD space.
#'
#' Both query_tf_idf and target_tf_idf must have common features.
#'
#' @param query_tf_idf
#' @param target_svd_loadings
#' @param target_svd SVD results for the target dataset, e.g. as generated by atac_svd() or atac_lsi()
#'
#' @return
#' @export
#'
atac_lsi_projection <- function(query_tf_idf,
                                target_svd) {

  common_features <- intersect(rownames(query_tf_idf),
                               rownames(target_svd$feature_loadings))

  query_tf_idf <- query_tf_idf[common_features,]
  target_loadings <- target_svd$feature_loadings[common_features,]

  query_projection <- Matrix::t(Matrix::crossprod(target_loadings,
                                                  query_tf_idf))

  colnames(query_projection) <- colnames(target_svd$pcs)

  as.matrix(query_projection)

}

# CCA function: Doesn't require common features
# atac_cca <- function(atac_lsi_1,
#                      atac_lsi_2,
#                      seed = 3030) {
#
#   atac_pcs_1 <- scale(atac_lsi_1$pcs, center = TRUE)
#   atac_pcs_2 <- scale(atac_lsi_2$pcs, center = TRUE)
#
#   crossprod_mat <- crossprod(atac_pcs_1,
#                              atac_pcs_2)
#
#   SVD <- irlba::irlba(cp_mat, 50, 50, maxit = 1000)
#
#   SVD_uv <- rbind(SVD$u, SVD$v)
#   colnames(SVD_uv) <- paste0("cc_", 1:50)
#   rownames(SVD_uv) <- c(colnames(atac_pcs_1),
#                         colnames(atac_pcs_2))
#   SVD_uv <- abs(SVD_uv)
#
#   list(ccv = SVD_uv,
#        d = SVD$d)
# }
