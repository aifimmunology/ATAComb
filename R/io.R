#' Read 10x scATAC-seq fragment data
#'
#' @param outs_dir An outs/ directory generated by cellranger-atac count. Must contain fragments.tsv.gz and singlecell.csv
#' @param min_reads A numeric value indicating the minimum number of reads required to retain a cell barcode. Default is 1000.
#' @param remove_chrM A logical value indicating whether or not to remove all fragments mapping to the mitochondrial genome. Default is TRUE
#' @param verbose A logical value indicating whether or not to display messages. Default is TRUE.
#'
#' @return a list of GenomicRanges objects, one per cell barcode
#' @export
read_10x_fragments <- function(outs_dir,
                               min_reads = 1000,
                               remove_chrM = TRUE,
                               verbose = TRUE) {

  fragments_file <- file.path(outs_dir, "fragments.tsv.gz")
  if(!file.exists(fragments_file)) {stop(paste("Can't find fragments.tsv.gz in", outs_dir))}

  singlecell_file <- file.path(outs_dir, "singlecell.csv")
  if(!file.exists(singlecell_file)) {stop(paste("Can't find singlecell.csv in", outs_dir))}

  if(verbose) {cat("reading singlecell.csv\n")}
  singlecell <- data.table::fread(singlecell_file)
  singlecell <- singlecell[-1,]
  if(verbose) {cat("filtering singlecell.csv\n")}
  singlecell <- singlecell[passed_filters >= min_reads,]

  if(verbose) {cat("reading fragments.tsv.gz\n")}
  fragments <- vroom::vroom(fragments_file,
                            delim = "\t",
                            col_names = c("chr","start","end","barcode","n_reads"),
                            col_types = c(chr = "c", start = "i", end = "i", barcode = "c", n_reads = "-"))

  if(verbose) {cat("filtering fragments.tsv.gz\n")}
  fragments <- fragments[fragments$barcode %in% singlecell$barcode,]

  if(remove_chrM) {
    if(verbose) {cat("removing chrM from fragments\n")}
    fragments <- fragments[!fragments$chr %in% c("chrM","chrMT","M","MT"),]
  }

  if(verbose) {cat("splitting fragments by barcode\n")}
  split_fragments <- split(fragments, fragments$barcode)

  return(split_fragments)
}


#' Convert a list of fragment data.table to GenomicRanges
#'
#' @param fragments A list of data.tables generated by read_10x_fragments()
#' @param n_threads A numeric value indicating how many threads to use for parallelization. Only works on UNIX-like systems. Default is 1.
#'
#' @return a list of GRanges objects
#' @export
convert_fragments_gr <- function(fragments,
                                 n_threads = 1) {
  if(n_threads == 1) {
    lapply(fragments,
           function(x) {
             GenomicRanges::GRanges(seqnames = x[["chr"]],
                                    IRanges::IRanges(start = x[["start"]],
                                                     end = x[["end"]]))
           })
  } else {
    starting_order <- names(fragments)
    res <- parallel::mclapply(fragments,
                              function(x) {
                                GenomicRanges::GRanges(seqnames = x[["chr"]],
                                                       IRanges::IRanges(start = x[["start"]],
                                                                        end = x[["end"]]))
                              },
                              mc.cores = n_threads)
    res <- res[starting_order]
    return(res)
  }
}


#' Convert a list of fragment data.tables to a sparse matrix of genomic window counts
#'
#' @param fragments A list of data.tables generated by read_10x_fragments()
#' @param window_size A numeric value specifying the size of windows to use as features. Default is 5000.
#' @param genome A character object specifying which genome to use. Should be one of "hg38","hg19","mm10", or "mm9". Default is "hg38".
#' @param n_threads A numeric value indicating how many threads to use for parallelization. Only works on UNIX-like systems. Default is 1.
#'
#' @return a list of GRanges objects
#' @export
convert_fragments_windows <- function(fragments,
                                      window_size = 5e3,
                                      genome = "hg38",
                                      n_threads = 1) {

  chrom_sizes <- read_chrom_sizes(genome = genome)

  if(n_threads == 1) {
    window_counts <- lapply(fragments,
                            fragments_to_window_counts,
                            chrom_sizes)
  } else {
    starting_order <- names(fragments)
    window_counts <- parallel::mclapply(fragments,
                                        fragments_to_window_counts,
                                        chrom_sizes,
                                        mc.cores = n_threads)
  }

  window_n_fragments <- unlist(lapply(window_counts, length))

  sparseMatrix(x = as.numeric(unlist(window_counts)),
               i = as.numeric(unlist(lapply(window_counts, names))),
               p = c(0, cumsum(window_n_fragments)),
               dim = c(sum(chrom_sizes$n_windows),
                       length(fragments)),
               dimnames = list(NULL,
                               names(fragments)))

}

#' Read chromosome sizes for a genome and precompute offsets for windowing
#'
#' All chromosome sizes are sourced from the UCSC Genome Browser
#'
#' @param genome A character object specifying which genome to use. Should be one of "hg38","hg19","mm10", or "mm9". Default is "hg38".
#' @param window_size A numeric value specifying the size of windows to use as features. Default is 5000.
#'
#' @return a data.frame with columns chr, size, n_windows, and offsets.
#' @export
read_chrom_sizes <- function(genome = "hg38",
                             window_size = 5e3) {

  chrom_sizes_file <- system.file(paste0("reference/",
                                         genome,
                                         ".chrom.sizes"),
                                  package = "ATAComb")

  chrom_sizes <- read.table(chrom_sizes_file,
                            col.names = c("chr","size"),
                            header = FALSE,
                            sep = "\t",
                            stringsAsFactors = FALSE)

  chrom_sizes$n_windows <- ceiling(chrom_sizes$size / window_size)
  chrom_sizes$offset <- c(0, cumsum(chrom_sizes$n_windows)[-nrow(chrom_sizes)])

  chrom_sizes
}

#' Convert a data.table of fragment positions to a named vector of window counts
#'
#' @param fragment_dt A data.table of fragment positions, e.g. as generated by read_10x_fragments()
#' @param chrom_sizes A data.frame of chromosome sizes, e.g. as generated by read_chrom_sizes()
#' @param window_size A numeric value specifying the size of windows to use as features. Default is 5000.
#'
#' @return A named numeric vector of reads per window. Names will be numeric window indexes.
#' @export
fragments_to_window_counts <- function(fragment_dt,
                                       chrom_sizes,
                                       window_size = 5e3) {

  centers <- (fragment_dt$end + fragment_dt$start)/2
  chr_windows <- floor(centers / window_size)

  adj_windows <- chr_windows + chrom_sizes$offset[match(fragment_dt[[1]], chrom_sizes$chr)]

  table(adj_windows)
}

#' Convert a vector of window indexes to a BED-like table of chromosome positions for each window.
#'
#' @param window_indexes a numeric vector of window indexes
#' @param chrom_sizes A data.frame of chromosome sizes, e.g. as generated by read_chrom_sizes()
#' @param window_size A numeric value specifying the size of windows to use as features. Default is 5000.
#'
#' @return a data.table of chromosome positions, with columns chr, start, and end
#' @export
window_index_to_bed <- function(window_indexes,
                                chrom_sizes,
                                window_size = 5e3) {

  chr_bin <- as.numeric(cut(window_indexes, chrom_sizes$offset))
  chr <- chrom_sizes$chr[chr_bin]

  chr_windows <- window_indexes - chrom_sizes$offset[chr_bin]

  data.table::data.table(chr = chr,
                         start = chr_windows * window_size,
                         end = (chr_windows + 1) * window_size)

}

#' Convert a vector of window indexes to GenomicRanges positions for each window.
#'
#' @param window_indexes a numeric vector of window indexes
#' @param chrom_sizes A data.frame of chromosome sizes, e.g. as generated by read_chrom_sizes()
#' @param window_size A numeric value specifying the size of windows to use as features. Default is 5000.
#'
#' @return a non-stranded GenomicRanges object
#' @export
window_index_to_gr <- function(window_indexes,
                               chrom_sizes,
                               window_size = 5e3) {

  chr_bin <- as.numeric(cut(window_indexes, chrom_sizes$offset))
  chr <- chrom_sizes$chr[chr_bin]

  chr_windows <- window_indexes - chrom_sizes$offset[chr_bin]

  GenomicRanges::GRanges(chr = chr,
                         IRanges::IRanges(start = chr_windows * window_size,
                                          end = (chr_windows + 1) * window_size))

}

merge_gr_list <- function(gr_list) {
  gr <- GenomicRanges::GRanges(seqnames = unlist(lapply(gr_list, GenomicRanges::seqnames)),
                               IRanges::IRanges(start = unlist(lapply(gr_list, GenomicRanges::start)),
                                                end = unlist(lapply(gr_list, GenomicRanges::end))),
                               strand = unlist(lapply(gr_list, GenomicRanges::strand)))

  GenomicRanges::sort(gr)
}
